// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/documents.proto

package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// CompressionCodec denotes whether and how the plaintext is compressed before encryption.
type CompressionCodec int32

const (
	CompressionCodec_NONE CompressionCodec = 0
	CompressionCodec_GZIP CompressionCodec = 1
)

var CompressionCodec_name = map[int32]string{
	0: "NONE",
	1: "GZIP",
}
var CompressionCodec_value = map[string]int32{
	"NONE": 0,
	"GZIP": 1,
}

func (x CompressionCodec) String() string {
	return proto.EnumName(CompressionCodec_name, int32(x))
}
func (CompressionCodec) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

// Document contains either an Envelope, Entry, or Page message.
type Document struct {
	// Types that are valid to be assigned to Contents:
	//	*Document_Envelope
	//	*Document_Entry
	//	*Document_Page
	Contents isDocument_Contents `protobuf_oneof:"contents"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

type isDocument_Contents interface {
	isDocument_Contents()
}

type Document_Envelope struct {
	Envelope *Envelope `protobuf:"bytes,1,opt,name=envelope,oneof"`
}
type Document_Entry struct {
	Entry *Entry `protobuf:"bytes,2,opt,name=entry,oneof"`
}
type Document_Page struct {
	Page *Page `protobuf:"bytes,3,opt,name=page,oneof"`
}

func (*Document_Envelope) isDocument_Contents() {}
func (*Document_Entry) isDocument_Contents()    {}
func (*Document_Page) isDocument_Contents()     {}

func (m *Document) GetContents() isDocument_Contents {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *Document) GetEnvelope() *Envelope {
	if x, ok := m.GetContents().(*Document_Envelope); ok {
		return x.Envelope
	}
	return nil
}

func (m *Document) GetEntry() *Entry {
	if x, ok := m.GetContents().(*Document_Entry); ok {
		return x.Entry
	}
	return nil
}

func (m *Document) GetPage() *Page {
	if x, ok := m.GetContents().(*Document_Page); ok {
		return x.Page
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Document) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Document_OneofMarshaler, _Document_OneofUnmarshaler, _Document_OneofSizer, []interface{}{
		(*Document_Envelope)(nil),
		(*Document_Entry)(nil),
		(*Document_Page)(nil),
	}
}

func _Document_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Document)
	// contents
	switch x := m.Contents.(type) {
	case *Document_Envelope:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Envelope); err != nil {
			return err
		}
	case *Document_Entry:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Entry); err != nil {
			return err
		}
	case *Document_Page:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Page); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Document.Contents has unexpected type %T", x)
	}
	return nil
}

func _Document_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Document)
	switch tag {
	case 1: // contents.envelope
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Envelope)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Envelope{msg}
		return true, err
	case 2: // contents.entry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Entry)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Entry{msg}
		return true, err
	case 3: // contents.page
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Page)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Page{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Document_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Document)
	// contents
	switch x := m.Contents.(type) {
	case *Document_Envelope:
		s := proto.Size(x.Envelope)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Document_Entry:
		s := proto.Size(x.Entry)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Document_Page:
		s := proto.Size(x.Page)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Envelope defines the public keys an author uses to share an entry encryption key with a
// particular reader. The shared ECDH secret is used with a key derivation function to generate the
// key encryption key (KEK), which contains 2 sub-keys:
// 1) 32-byte AES-256 key, used for encrypting/decrypting the entry encryption key (EEK)
// 2) 12-byte EEK block cipher initialization vector
// 3) 32-byte HMAC-256 key, used for EEK MAC
//
// This AES-256 EEK is then used to decrypt the EEK ciphertext, which contains 4 sub-keys:
// 1) 32-byte AES-256 key, used to enrypt Pages and Entry metadata
// 2) 32-byte Page initialization vector (IV) seed
// 3) 32-byte HMAC-256 key
// 4) 12-byte metadata block cipher initialization vector
type Envelope struct {
	// 32-byte key of the Entry whose encryption keys are being sent
	EntryKey []byte `protobuf:"bytes,1,opt,name=entry_key,json=entryKey,proto3" json:"entry_key,omitempty"`
	// ECDH public key of the entry author/sender
	AuthorPublicKey []byte `protobuf:"bytes,2,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// ECDH public key of the entry reader/recipient
	ReaderPublicKey []byte `protobuf:"bytes,3,opt,name=reader_public_key,json=readerPublicKey,proto3" json:"reader_public_key,omitempty"`
	// ciphertext of 108-byte entry encryption key (EEK), encrypted with a KEK from the shared
	// ECDH shared secret
	EekCiphertext []byte `protobuf:"bytes,4,opt,name=eek_ciphertext,json=eekCiphertext,proto3" json:"eek_ciphertext,omitempty"`
	// 32-byte MAC of the EEK
	EekCiphertextMac []byte `protobuf:"bytes,5,opt,name=eek_ciphertext_mac,json=eekCiphertextMac,proto3" json:"eek_ciphertext_mac,omitempty"`
}

func (m *Envelope) Reset()                    { *m = Envelope{} }
func (m *Envelope) String() string            { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()               {}
func (*Envelope) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *Envelope) GetEntryKey() []byte {
	if m != nil {
		return m.EntryKey
	}
	return nil
}

func (m *Envelope) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Envelope) GetReaderPublicKey() []byte {
	if m != nil {
		return m.ReaderPublicKey
	}
	return nil
}

func (m *Envelope) GetEekCiphertext() []byte {
	if m != nil {
		return m.EekCiphertext
	}
	return nil
}

func (m *Envelope) GetEekCiphertextMac() []byte {
	if m != nil {
		return m.EekCiphertextMac
	}
	return nil
}

// Entry is the main unit of cache in the Libri network.
type Entry struct {
	// ECDSA public key of the entry author
	AuthorPublicKey []byte `protobuf:"bytes,1,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// single-page contents of the entry, set when page_keys is not set
	Page *Page `protobuf:"bytes,2,opt,name=page" json:"page,omitempty"`
	// multi-page contents of the entry, set when page is not set
	PageKeys [][]byte `protobuf:"bytes,3,rep,name=page_keys,json=pageKeys,proto3" json:"page_keys,omitempty"`
	// created epoch time (seconds since 1970-01-01)
	CreatedTime uint32 `protobuf:"varint,4,opt,name=created_time,json=createdTime" json:"created_time,omitempty"`
	// ciphertext of marshalled EntryMetadata message properties
	MetadataCiphertext []byte `protobuf:"bytes,5,opt,name=metadata_ciphertext,json=metadataCiphertext,proto3" json:"metadata_ciphertext,omitempty"`
	// 32-byte MAC of metatadata ciphertext, encrypted with the 32-byte Entry AES-256 key and
	// 12-byte metadata block cipher IV
	MetadataCiphertextMac []byte `protobuf:"bytes,6,opt,name=metadata_ciphertext_mac,json=metadataCiphertextMac,proto3" json:"metadata_ciphertext_mac,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *Entry) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Entry) GetPage() *Page {
	if m != nil {
		return m.Page
	}
	return nil
}

func (m *Entry) GetPageKeys() [][]byte {
	if m != nil {
		return m.PageKeys
	}
	return nil
}

func (m *Entry) GetCreatedTime() uint32 {
	if m != nil {
		return m.CreatedTime
	}
	return 0
}

func (m *Entry) GetMetadataCiphertext() []byte {
	if m != nil {
		return m.MetadataCiphertext
	}
	return nil
}

func (m *Entry) GetMetadataCiphertextMac() []byte {
	if m != nil {
		return m.MetadataCiphertextMac
	}
	return nil
}

// EntryMetadata contains metadata for an entry.
type EntryMetadata struct {
	// media/MIME type of the data
	MediaType string `protobuf:"bytes,1,opt,name=media_type,json=mediaType" json:"media_type,omitempty"`
	// codec used to compress the data
	CompressionCodec CompressionCodec `protobuf:"varint,2,opt,name=compression_codec,json=compressionCodec,enum=api.CompressionCodec" json:"compression_codec,omitempty"`
	// total ciphertext size across all pages
	CiphertextSize uint64 `protobuf:"varint,3,opt,name=ciphertext_size,json=ciphertextSize" json:"ciphertext_size,omitempty"`
	// MAC of the entire ciphertext
	CiphertextMac []byte `protobuf:"bytes,4,opt,name=ciphertext_mac,json=ciphertextMac,proto3" json:"ciphertext_mac,omitempty"`
	// total size of the entire uncompressed entry
	UncompressedSize uint64 `protobuf:"varint,5,opt,name=uncompressed_size,json=uncompressedSize" json:"uncompressed_size,omitempty"`
	// MAC of the entire uncompressed entry
	UncompressedMac []byte `protobuf:"bytes,6,opt,name=uncompressed_mac,json=uncompressedMac,proto3" json:"uncompressed_mac,omitempty"`
	// domain-specific metadata
	Properties map[string][]byte `protobuf:"bytes,7,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// (relative) filepath of the data contained in the entry
	Filepath string `protobuf:"bytes,8,opt,name=filepath" json:"filepath,omitempty"`
	// schema of the entry plaintext
	Schema *SchemaArtifact `protobuf:"bytes,9,opt,name=schema" json:"schema,omitempty"`
	// data dictionary of the entry plaintext
	DataDictionary *SchemaArtifact `protobuf:"bytes,10,opt,name=dataDictionary" json:"dataDictionary,omitempty"`
}

func (m *EntryMetadata) Reset()                    { *m = EntryMetadata{} }
func (m *EntryMetadata) String() string            { return proto.CompactTextString(m) }
func (*EntryMetadata) ProtoMessage()               {}
func (*EntryMetadata) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *EntryMetadata) GetMediaType() string {
	if m != nil {
		return m.MediaType
	}
	return ""
}

func (m *EntryMetadata) GetCompressionCodec() CompressionCodec {
	if m != nil {
		return m.CompressionCodec
	}
	return CompressionCodec_NONE
}

func (m *EntryMetadata) GetCiphertextSize() uint64 {
	if m != nil {
		return m.CiphertextSize
	}
	return 0
}

func (m *EntryMetadata) GetCiphertextMac() []byte {
	if m != nil {
		return m.CiphertextMac
	}
	return nil
}

func (m *EntryMetadata) GetUncompressedSize() uint64 {
	if m != nil {
		return m.UncompressedSize
	}
	return 0
}

func (m *EntryMetadata) GetUncompressedMac() []byte {
	if m != nil {
		return m.UncompressedMac
	}
	return nil
}

func (m *EntryMetadata) GetProperties() map[string][]byte {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *EntryMetadata) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *EntryMetadata) GetSchema() *SchemaArtifact {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *EntryMetadata) GetDataDictionary() *SchemaArtifact {
	if m != nil {
		return m.DataDictionary
	}
	return nil
}

// SchemaArtifact denotes the schema artifact associated with the serialized plaintext of a
// particular entry. Artifacts can mainly be two separate types:
//
// - schema: can be of any type (e.g., proto, avro, json, XML, XSD, etc) that minimally describe the
// format of the data and optionally/preferably also include the data dictionary (i.e., the
// semantic meaning of the schema components) as well.
//
// - data dictionary: when the schema is broad/loose (as is the case in some standard data formats
// like HL7), this additional documentation adds clarity about the semantic meaning/use of each
// field. For example, a schema may contain two similar fields, A1 and A2, and one entry
// data producer may store a value in A1, whereas another producer may store the same semantic
// value in A2. The schema for both messages is the same, but the schema interpretation is
// different.
//
// New schemas should obviously be as well-defined and unambiguous as possible, but many legacy
// data formats require additional interpretation. Clients can choose to do what they want with
// the schema and data dictionary, but commonly they will have combinations of these that they
// know how to handle explicitly.
//
// Preferred formats:
//  - schema: Protobuf
//  - data dictionary: Markdown
//
type SchemaArtifact struct {
	// group owning the schema (commonly a Github user, e.g., 'drausin')
	Group string `protobuf:"bytes,1,opt,name=group" json:"group,omitempty"`
	// project in which schema resides (commonly a Github project, e.g., 'libri')
	Project string `protobuf:"bytes,2,opt,name=project" json:"project,omitempty"`
	// path to schema file within project (e.g., 'libri/librarian/api/documents.proto')
	Path string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
	// (optional) name of schema within file (e.g., 'EntrySchema')
	Name string `protobuf:"bytes,4,opt,name=name" json:"name,omitempty"`
	// version of schema (commonly a semver tag, e.g., '0.1.0')
	Version string `protobuf:"bytes,5,opt,name=version" json:"version,omitempty"`
}

func (m *SchemaArtifact) Reset()                    { *m = SchemaArtifact{} }
func (m *SchemaArtifact) String() string            { return proto.CompactTextString(m) }
func (*SchemaArtifact) ProtoMessage()               {}
func (*SchemaArtifact) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *SchemaArtifact) GetGroup() string {
	if m != nil {
		return m.Group
	}
	return ""
}

func (m *SchemaArtifact) GetProject() string {
	if m != nil {
		return m.Project
	}
	return ""
}

func (m *SchemaArtifact) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *SchemaArtifact) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SchemaArtifact) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// Page is a portion (possibly all) of an Entry document.
type Page struct {
	// ECDSA public key of the entry author
	AuthorPublicKey []byte `protobuf:"bytes,1,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// index of Page within Entry contents
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	// ciphertext of Page contents, encrypted using the 32-byte AES-256 key with the block cipher
	// initialized by the first 12 bytes of HMAC-256(IV seed, page index)
	Ciphertext []byte `protobuf:"bytes,3,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// 32-byte MAC of ciphertext using the 32-byte Page ciphertext HMAC-256 key
	CiphertextMac []byte `protobuf:"bytes,4,opt,name=ciphertext_mac,json=ciphertextMac,proto3" json:"ciphertext_mac,omitempty"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *Page) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Page) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Page) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *Page) GetCiphertextMac() []byte {
	if m != nil {
		return m.CiphertextMac
	}
	return nil
}

func init() {
	proto.RegisterType((*Document)(nil), "api.Document")
	proto.RegisterType((*Envelope)(nil), "api.Envelope")
	proto.RegisterType((*Entry)(nil), "api.Entry")
	proto.RegisterType((*EntryMetadata)(nil), "api.EntryMetadata")
	proto.RegisterType((*SchemaArtifact)(nil), "api.SchemaArtifact")
	proto.RegisterType((*Page)(nil), "api.Page")
	proto.RegisterEnum("api.CompressionCodec", CompressionCodec_name, CompressionCodec_value)
}

func init() { proto.RegisterFile("api/documents.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 710 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x4d, 0x4f, 0xdb, 0x4a,
	0x14, 0xc5, 0xf9, 0x80, 0xf8, 0x42, 0x3e, 0x18, 0x40, 0xcf, 0xe2, 0x89, 0xf7, 0x78, 0x91, 0x5e,
	0x4b, 0xa1, 0x0a, 0x12, 0x95, 0xaa, 0xaa, 0x55, 0x17, 0xe5, 0x43, 0xa5, 0x42, 0xd0, 0xc8, 0xb0,
	0xea, 0x26, 0x1a, 0xc6, 0x17, 0x32, 0x25, 0xb6, 0x47, 0xe3, 0x09, 0xc2, 0x2c, 0xbb, 0xea, 0xae,
	0x3f, 0xa2, 0x7f, 0xa9, 0xff, 0xa6, 0x9b, 0x6a, 0xae, 0x9d, 0xc4, 0x49, 0xa9, 0xd4, 0xae, 0x3c,
	0x73, 0xee, 0x99, 0x33, 0xf7, 0x9e, 0xb9, 0xd7, 0xb0, 0xc2, 0x95, 0xdc, 0x0d, 0x62, 0x31, 0x0c,
	0x31, 0x32, 0x49, 0x47, 0xe9, 0xd8, 0xc4, 0xac, 0xcc, 0x95, 0x6c, 0x7f, 0x76, 0xa0, 0x76, 0x98,
	0x07, 0xd8, 0x0e, 0xd4, 0x30, 0xba, 0xc5, 0x41, 0xac, 0xd0, 0x73, 0x36, 0x9d, 0xad, 0xc5, 0xbd,
	0x7a, 0x87, 0x2b, 0xd9, 0x39, 0xca, 0xc1, 0xe3, 0x39, 0x7f, 0x4c, 0x60, 0x6d, 0xa8, 0x62, 0x64,
	0x74, 0xea, 0x95, 0x88, 0x09, 0x39, 0xd3, 0xe8, 0xf4, 0x78, 0xce, 0xcf, 0x42, 0xec, 0x5f, 0xa8,
	0x28, 0x7e, 0x8d, 0x5e, 0x99, 0x28, 0x2e, 0x51, 0xba, 0xfc, 0xda, 0x0a, 0x51, 0x60, 0x1f, 0xa0,
	0x26, 0xe2, 0xc8, 0xd8, 0xac, 0xda, 0xdf, 0x1c, 0xa8, 0x8d, 0x6e, 0x62, 0x7f, 0x83, 0x4b, 0x12,
	0xbd, 0x1b, 0x4c, 0x29, 0x97, 0x25, 0x7b, 0xb5, 0xd1, 0xe9, 0x09, 0xa6, 0x6c, 0x1b, 0x96, 0xf9,
	0xd0, 0xf4, 0x63, 0xdd, 0x53, 0xc3, 0xcb, 0x81, 0x14, 0x44, 0x2a, 0x11, 0xa9, 0x99, 0x05, 0xba,
	0x84, 0xe7, 0x5c, 0x8d, 0x3c, 0xc0, 0x29, 0x6e, 0x39, 0xe3, 0x66, 0x81, 0x09, 0xf7, 0x7f, 0x68,
	0x20, 0xde, 0xf4, 0x84, 0x54, 0x7d, 0xd4, 0x06, 0xef, 0x8c, 0x57, 0x21, 0x62, 0x1d, 0xf1, 0xe6,
	0x60, 0x0c, 0xb2, 0xa7, 0xc0, 0xa6, 0x69, 0xbd, 0x90, 0x0b, 0xaf, 0x4a, 0xd4, 0xd6, 0x14, 0xf5,
	0x94, 0x8b, 0xf6, 0x77, 0x07, 0xaa, 0x64, 0xcb, 0xc3, 0x69, 0x3b, 0x0f, 0xa7, 0xbd, 0x91, 0x3b,
	0x57, 0x9a, 0x71, 0x2e, 0xf3, 0xcd, 0xda, 0x63, 0xbf, 0x56, 0x21, 0xf1, 0xca, 0x9b, 0x65, 0x6b,
	0x8f, 0x05, 0x4e, 0x30, 0x4d, 0xd8, 0x7f, 0xb0, 0x24, 0x34, 0x72, 0x83, 0x41, 0xcf, 0xc8, 0x10,
	0xa9, 0x88, 0xba, 0xbf, 0x98, 0x63, 0x17, 0x32, 0x44, 0xb6, 0x0b, 0x2b, 0x21, 0x1a, 0x1e, 0x70,
	0xc3, 0x8b, 0xe5, 0x66, 0x35, 0xb0, 0x51, 0xa8, 0x50, 0xf3, 0x73, 0xf8, 0xeb, 0x81, 0x03, 0x54,
	0xf8, 0x3c, 0x1d, 0x5a, 0xfb, 0xf9, 0x90, 0xad, 0xfe, 0x6b, 0x05, 0xea, 0x54, 0xfd, 0x69, 0x1e,
	0x66, 0x1b, 0x00, 0x21, 0x06, 0x92, 0xf7, 0x4c, 0x9a, 0xb7, 0x99, 0xeb, 0xbb, 0x84, 0x5c, 0xa4,
	0x0a, 0xd9, 0x3e, 0x2c, 0x8b, 0x38, 0x54, 0x1a, 0x93, 0x44, 0xc6, 0x51, 0x4f, 0xc4, 0x01, 0x0a,
	0x72, 0xa1, 0xb1, 0xb7, 0x46, 0x2e, 0x1c, 0x4c, 0xa2, 0x07, 0x36, 0xe8, 0xb7, 0xc4, 0x0c, 0xc2,
	0x1e, 0x43, 0xb3, 0x90, 0x63, 0x22, 0xef, 0xb3, 0x0e, 0xac, 0xf8, 0x8d, 0x09, 0x7c, 0x2e, 0xef,
	0xd1, 0x3e, 0xf8, 0x4c, 0x31, 0xf9, 0x83, 0x8b, 0x62, 0x11, 0x6c, 0x07, 0x96, 0x87, 0xd1, 0xe8,
	0x16, 0x0c, 0x32, 0xc5, 0x2a, 0x29, 0xb6, 0x8a, 0x01, 0xd2, 0x7c, 0x02, 0x53, 0x58, 0xc1, 0xa2,
	0x66, 0x11, 0xb7, 0xba, 0xfb, 0x00, 0x4a, 0xc7, 0x0a, 0xb5, 0x91, 0x98, 0x78, 0x0b, 0x9b, 0xe5,
	0xad, 0xc5, 0xbd, 0xf6, 0x64, 0x8e, 0x46, 0x96, 0x75, 0xba, 0x63, 0x12, 0xe1, 0x7e, 0xe1, 0x14,
	0x5b, 0x87, 0xda, 0x95, 0x1c, 0xa0, 0xe2, 0xa6, 0xef, 0xd5, 0xc8, 0xcc, 0xf1, 0x9e, 0xed, 0xc0,
	0x7c, 0x22, 0xfa, 0x18, 0x72, 0xcf, 0xa5, 0x36, 0x5a, 0x21, 0xed, 0x73, 0x82, 0xde, 0x68, 0x23,
	0xaf, 0xb8, 0x30, 0x7e, 0x4e, 0x61, 0xaf, 0xa0, 0x61, 0x2f, 0x3b, 0x94, 0xc2, 0xc8, 0x38, 0xe2,
	0x3a, 0xf5, 0xe0, 0xd7, 0x87, 0x66, 0xa8, 0xeb, 0xaf, 0xa1, 0x39, 0x93, 0x24, 0x6b, 0x41, 0x79,
	0xd4, 0xdf, 0xae, 0x6f, 0x97, 0x6c, 0x15, 0xaa, 0xb7, 0x7c, 0x30, 0xc4, 0x7c, 0x54, 0xb3, 0xcd,
	0xcb, 0xd2, 0x0b, 0xa7, 0xfd, 0xc9, 0x81, 0xc6, 0xf4, 0x0d, 0x96, 0x7c, 0xad, 0xe3, 0xa1, 0xca,
	0x05, 0xb2, 0x0d, 0xf3, 0x60, 0x41, 0xe9, 0xf8, 0x23, 0x0a, 0x43, 0x22, 0xae, 0x3f, 0xda, 0x32,
	0x66, 0x07, 0xc6, 0xf4, 0xe9, 0xa1, 0x5d, 0x9f, 0xd6, 0x16, 0x8b, 0x78, 0x3e, 0x00, 0xae, 0x4f,
	0x6b, 0xab, 0x70, 0x8b, 0xda, 0xf6, 0x0a, 0xbd, 0xa0, 0xeb, 0x8f, 0xb6, 0xed, 0x2f, 0x0e, 0x54,
	0xec, 0x88, 0xfd, 0xd1, 0x9c, 0xae, 0x42, 0x55, 0x46, 0x01, 0xde, 0x51, 0x3a, 0x75, 0x3f, 0xdb,
	0xb0, 0x7f, 0x00, 0x0a, 0x53, 0x95, 0xfd, 0x6d, 0x0a, 0xc8, 0x6f, 0xf6, 0xdd, 0xf6, 0x23, 0x68,
	0xcd, 0x76, 0x3b, 0xab, 0x41, 0xe5, 0xec, 0xfd, 0xd9, 0x51, 0x6b, 0xce, 0xae, 0xde, 0x7e, 0x78,
	0xd7, 0x6d, 0x39, 0x97, 0xf3, 0xf4, 0x43, 0x7f, 0xf6, 0x23, 0x00, 0x00, 0xff, 0xff, 0x34, 0x1e,
	0x5d, 0x3a, 0xe7, 0x05, 0x00, 0x00,
}
